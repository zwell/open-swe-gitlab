import { GraphConfig, TaskPlan } from "@open-swe/shared/open-swe/types";
import {
  ManagerGraphState,
  ManagerGraphUpdate,
} from "@open-swe/shared/open-swe/manager/types";
import { createLangGraphClient } from "../../../utils/langgraph-client.js";
import {
  GITHUB_INSTALLATION_TOKEN_COOKIE,
  GITHUB_TOKEN_COOKIE,
} from "@open-swe/shared/constants";
import {
  BaseMessage,
  HumanMessage,
  isHumanMessage,
  RemoveMessage,
} from "@langchain/core/messages";
import { z } from "zod";
import { removeLastHumanMessage } from "../../../utils/message/modify-array.js";
import { formatPlanPrompt } from "../../../utils/plan-prompt.js";
import { getActivePlanItems } from "@open-swe/shared/open-swe/tasks";
import { getMessageString } from "../../../utils/message/content.js";
import { loadModel, Task } from "../../../utils/load-model.js";
import { Command, END } from "@langchain/langgraph";
import { getMessageContentString } from "@open-swe/shared/messages";
import { createIssue, createIssueComment } from "../../../utils/github/api.js";
import { getGitHubTokensFromConfig } from "../../../utils/github-tokens.js";
import { createIssueTitleAndBodyFromMessages } from "../utils/generate-issue-fields.js";
import { ThreadStatus } from "@langchain/langgraph-sdk";
import {
  extractIssueTitleAndContentFromMessage,
  formatContentForIssueBody,
} from "../../../utils/github/issue-messages.js";

// This should not be shown to the user if the programmer is running
const PLAN_ROUTING_OPTION = `- plan: Call this route if the user's message is a complete request which you can use to kickoff a new planning session (only if one is not already running), or it's an entirely new request which you should also start a new planning session for (only if both the planner and programmer are not running). You may also call this route if the planner is running, and the user's message contains updated instructions, or additional context which may be relevant/helpful to the planner.`;

// This should only be included in the state when the programmer is running.
const CODE_ROUTING_OPTION = `- code: Call this route if the user's message should be added to the programmer's currently running session. This should be called if you determine the user is trying to provide extra context to the programmer.`;

// This should only be included when the programmer/planner is running.
const CREATE_ISSUE_ROUTING_OPTION = `- create_new_issue: Call this route if the user's request should create a new GitHub issue, and should be executed independently from the current request. This should only be called if the new request does not depend on the current request.`;

// This should only be included if the task plan exists.
const TASK_PLAN_PROMPT = `# Task Plan
The following is the current state of the task plan generated by the planner. You should use this as context when determining where to route the user's message, and how to reply to them.
{TASK_PLAN}
\n\n`;

const CONVERSATION_HISTORY_PROMPT = `# Conversation History
The following is the conversation history between the user and you. This does not include their most recent message, which is the one you are currently classifying. You should use this as context when determining where to route the user's message, and how to reply to them.
{CONVERSATION_HISTORY}
\n\n`;

// This prompt does not generate the route, it only generates the response.
const CLASSIFICATION_SYSTEM_PROMPT = `# Identity
You're a highly intelligent AI software engineering manager, tasked with identifying the user's intent, and responding to their message, and determining how you'll route it to the proper AI assistant.
Your overall system is an AI coding agent, tasked with completing user's requests to improve their codebase.

# Instructions
Carefully examine the user's message, along with the conversation history provided (or none, if it's the first message they sent) to you in this system message below.
Using their most recent request, the conversation history, and the current status of your two AI assistants (programmer and planner), generate a response to send to the user.
Below you're provided with routes to take given the user's request. You should not select a route in this step, but your response should make it clear which route you'll take. (the routing will handle in a step which is not exposed to the user).
Ensure your response is clear, and concise. You should not explicitly state which route you're taking, but it should be obvious to anyone who also knows what routes are available.
Although you're only supposed to classify & respond to the latest message, this does not mean you should look at it in isolation. You should consider the conversation history as a whole, and the current status of your two AI assistants (programmer and planner) to determine how to respond to the user's new message.

# Assistant Statuses
The planner's current status is: {PLANNER_STATUS}
The programmer's current status is: {PROGRAMMER_STATUS}

{TASK_PLAN_PROMPT}
{CONVERSATION_HISTORY_PROMPT}

# Routing Options
Based on all of the context provided above, generate a response to send to the user, including messaging about the route you'll select from the below options in your next step.
Your routing options are:
- no_op: This should be called when the user's message does not warrant starting a new planning session, or updating the running session, or the same with the programmer if it's already running.
{PLAN_ROUTING_OPTION}
{CREATE_ISSUE_ROUTING_OPTION}
{CODE_ROUTING_OPTION}

# Response
Your response should be clear, concise and straight to the point. Do NOT include any additional context, such as an idea for how to implement their request.
You're only acting as a manager, and thus you should only respond with a short message about which route you'll take. You do not need to explain why you're taking that route.
Your response will not exceed two sentences. You will be rewarded for being concise.
`;

// This prompt uses the response to generate the route.
const ROUTING_SYSTEM_PROMPT = `# Identity
You're a highly intelligent AI software engineering manager, tasked with identifying the user's intent, and responding to their message, plus routing it to the proper AI assistant.
Your overall system is an AI coding agent, tasked with completing user's requests to improve their codebase.

# Instructions
Carefully examine the user's message,  the conversation history provided (or none, if it's the first message they sent) to you in this system message below, and the response you just generated in the previous step.
Using their most recent request, and your response to the user (which will contain context about how you should route the user's message), and the current status of your two AI assistants (programmer and planner), call the \`respond_and_route\` tool to route the user's response.

# Assistant Statuses
The planner's current status is: {PLANNER_STATUS}
The programmer's current status is: {PROGRAMMER_STATUS}

{TASK_PLAN_PROMPT}
{CONVERSATION_HISTORY_PROMPT}

# Response
This is the response you just generated which was sent to the user. It will include context about how/what route you should take. Pay careful attention to this response, and ensure you're following it.
{ROUTING_RESPONSE}

# Routing Options
Based on all of the context provided above, generate a response to send to the user, including messaging about the route you'll select from the below options in your next step.
Your routing options are:
- no_op: This should be called when the user's message does not warrant starting a new planning session, or updating the running session, or the same with the programmer if it's already running.
{PLAN_ROUTING_OPTION}
{CREATE_ISSUE_ROUTING_OPTION}
{CODE_ROUTING_OPTION}`;

const baseClassificationSchema = z.object({
  response: z
    .string()
    .describe(
      "The response to send to the user. This should be clear, concise, and include any additional context the user may need to know about how/why you're handling their new message.",
    ),
  route: z
    .enum(["no_op"])
    .describe("The route to take to handle the user's new message."),
});

const createClassificationPromptAndToolSchema = (inputs: {
  programmerStatus: ThreadStatus | "not_started";
  plannerStatus: ThreadStatus | "not_started";
  messages: BaseMessage[];
  taskPlan: TaskPlan;
  routingResponse?: string;
}): {
  prompt: string;
  schema: z.ZodTypeAny;
} => {
  const conversationHistoryWithoutLatest = removeLastHumanMessage(
    inputs.messages,
  );
  const formattedTaskPlanPrompt = inputs.taskPlan
    ? TASK_PLAN_PROMPT.replaceAll(
        "{TASK_PLAN}",
        formatPlanPrompt(getActivePlanItems(inputs.taskPlan)),
      )
    : null;
  const formattedConversationHistoryPrompt =
    conversationHistoryWithoutLatest?.length
      ? CONVERSATION_HISTORY_PROMPT.replaceAll(
          "{CONVERSATION_HISTORY}",
          conversationHistoryWithoutLatest.map(getMessageString).join("\n"),
        )
      : null;

  const programmerIsRunning = inputs.programmerStatus === "busy";
  const showCreateIssueRoutingOption =
    inputs.programmerStatus !== "not_started" ||
    inputs.plannerStatus !== "not_started";

  const systemPrompt = inputs.routingResponse
    ? ROUTING_SYSTEM_PROMPT
    : CLASSIFICATION_SYSTEM_PROMPT;

  const prompt = systemPrompt
    .replaceAll("{PROGRAMMER_STATUS}", inputs.programmerStatus)
    .replaceAll("{PLANNER_STATUS}", inputs.plannerStatus)
    .replaceAll(
      "{CODE_ROUTING_OPTION}",
      programmerIsRunning ? CODE_ROUTING_OPTION : "",
    )
    // Only show the planner option if the programmer is not running
    .replaceAll(
      "{PLAN_ROUTING_OPTION}",
      !programmerIsRunning ? PLAN_ROUTING_OPTION : "",
    )
    .replaceAll(
      "{CREATE_ISSUE_ROUTING_OPTION}",
      // Do not show the create new issue option if both the planner & programmer have not started
      // if either have started/currently running/completed, show the option
      showCreateIssueRoutingOption ? CREATE_ISSUE_ROUTING_OPTION : "",
    )
    .replaceAll("{TASK_PLAN_PROMPT}", formattedTaskPlanPrompt ?? "")
    .replaceAll(
      "{CONVERSATION_HISTORY_PROMPT}",
      formattedConversationHistoryPrompt ?? "",
    )
    .replaceAll("{ROUTING_RESPONSE}", inputs.routingResponse ?? "");

  const schema = baseClassificationSchema.extend({
    route: z
      .enum([
        "no_op",
        ...(programmerIsRunning ? ["code"] : []),
        ...(!programmerIsRunning ? ["plan"] : []),
        ...(showCreateIssueRoutingOption ? ["create_new_issue"] : []),
      ])
      .describe("The route to take to handle the user's new message."),
  });

  return {
    prompt,
    schema,
  };
};

/**
 * Classify the latest human message to determine how to route the request.
 * Requests can be routed to:
 * 1. reply - dont need to plan, just reply. This could be if the user sends a message which is not classified as a request, or if the programmer/planner is already running.
 *   a. if the planner/programmer is already running, we'll simply reply with
 */
export async function classifyMessage(
  state: ManagerGraphState,
  config: GraphConfig,
): Promise<Command> {
  const userMessage = state.messages.findLast(isHumanMessage);
  if (!userMessage) {
    throw new Error("No human message found.");
  }

  const langGraphClient = createLangGraphClient({
    defaultHeaders: {
      [GITHUB_TOKEN_COOKIE]: config.configurable?.[GITHUB_TOKEN_COOKIE] ?? "",
      [GITHUB_INSTALLATION_TOKEN_COOKIE]:
        config.configurable?.[GITHUB_INSTALLATION_TOKEN_COOKIE] ?? "",
    },
  });

  const [programmerThread, plannerThread] = await Promise.all([
    state.programmerSession?.threadId
      ? langGraphClient.threads.get(state.programmerSession.threadId)
      : undefined,
    state.plannerSession?.threadId
      ? langGraphClient.threads.get(state.plannerSession.threadId)
      : undefined,
  ]);
  const programmerStatus = programmerThread?.status ?? "not_started";
  const plannerStatus = plannerThread?.status ?? "not_started";

  const { prompt: responsePrompt } = createClassificationPromptAndToolSchema({
    programmerStatus,
    plannerStatus,
    messages: state.messages,
    taskPlan: state.taskPlan,
  });

  const model = await loadModel(config, Task.CLASSIFICATION);
  const response = await model.invoke([
    {
      role: "system",
      content: responsePrompt,
    },
    userMessage,
  ]);

  // Get the new prompt, this time passing the `routingResponse` to the prompt.
  const { prompt: routingPrompt, schema } =
    createClassificationPromptAndToolSchema({
      programmerStatus,
      plannerStatus,
      messages: state.messages,
      taskPlan: state.taskPlan,
      routingResponse: getMessageContentString(response.content),
    });
  const respondAndRouteTool = {
    name: "respond_and_route",
    description: "Respond to the user's message and determine how to route it.",
    schema,
  };
  const modelWithTools = model.bindTools([respondAndRouteTool], {
    tool_choice: respondAndRouteTool.name,
    parallel_tool_calls: false,
  });

  const toolCallingResponse = await modelWithTools
    .withConfig({ tags: ["nostream"] })
    .invoke([
      {
        role: "system",
        content: routingPrompt,
      },
      userMessage,
    ]);

  const toolCall = toolCallingResponse.tool_calls?.[0];
  if (!toolCall) {
    throw new Error("No tool call found.");
  }
  const toolCallArgs = toolCall.args as z.infer<
    typeof baseClassificationSchema
  >;

  if (toolCallArgs.route === "no_op") {
    // If it's a no_op, just add the message to the state and return.
    const commandUpdate: ManagerGraphUpdate = {
      messages: [response],
    };
    return new Command({
      update: commandUpdate,
      goto: END,
    });
  }

  if ((toolCallArgs.route as string) === "create_new_issue") {
    // Route to node which kicks off new manager run, passing in the full conversation history.
    const commandUpdate: ManagerGraphUpdate = {
      messages: [response],
    };
    return new Command({
      update: commandUpdate,
      goto: "create-new-session",
    });
  }

  const { githubAccessToken } = getGitHubTokensFromConfig(config);
  let githubIssueId = state.githubIssueId;

  const newMessages: BaseMessage[] = [response];

  // If it's not a no_op, ensure there is a GitHub issue with the user's request.
  if (!githubIssueId) {
    // If there are multiple human messages in the state, generate a github issue with an LLM.
    // Otherwise extract it from the user's message.
    let title = "";
    let body = "";
    if (state.messages.filter(isHumanMessage).length > 1) {
      const titleAndContent = await createIssueTitleAndBodyFromMessages(
        state.messages,
        config,
      );
      title = titleAndContent.title;
      body = titleAndContent.body;
    } else {
      const titleAndContent = extractIssueTitleAndContentFromMessage(
        getMessageContentString(userMessage.content),
      );
      title = titleAndContent.title;
      body = titleAndContent.content;
    }

    const newIssue = await createIssue({
      owner: state.targetRepository.owner,
      repo: state.targetRepository.repo,
      title,
      body: formatContentForIssueBody(body),
      githubAccessToken,
    });
    if (!newIssue) {
      throw new Error("Failed to create issue.");
    }
    githubIssueId = newIssue.number;
    // Ensure we remove the old message, and replace it with an exact copy,
    // but with the issue ID & isOriginalIssue set in additional_kwargs.
    newMessages.push(
      ...[
        new RemoveMessage({
          id: userMessage.id ?? "",
        }),
        new HumanMessage({
          ...userMessage,
          additional_kwargs: {
            githubIssueId: githubIssueId,
            isOriginalIssue: true,
          },
        }),
      ],
    );
  } else if (
    githubIssueId &&
    state.messages.filter(isHumanMessage).length > 1
  ) {
    // If there already is a GitHub issue ID in state, and multiple human messages, add any
    // human messages to the issue which weren't already added.
    const messagesNotInIssue = state.messages
      .filter(isHumanMessage)
      .filter((message) => {
        // If the message doesn't contain `githubIssueId` in additional kwargs, it hasn't been added to the issue.
        return !message.additional_kwargs?.githubIssueId;
      });

    const createCommentsPromise = messagesNotInIssue.map(async (message) => {
      const createdIssue = await createIssueComment({
        owner: state.targetRepository.owner,
        repo: state.targetRepository.repo,
        issueNumber: githubIssueId,
        body: getMessageContentString(message.content),
        githubToken: githubAccessToken,
      });
      if (!createdIssue?.id) {
        throw new Error("Failed to create issue comment");
      }
      newMessages.push(
        ...[
          new RemoveMessage({
            id: message.id ?? "",
          }),
          new HumanMessage({
            ...message,
            additional_kwargs: {
              githubIssueId: githubIssueId,
              githubIssueCommentId: createdIssue.id,
            },
          }),
        ],
      );
    });

    await Promise.all(createCommentsPromise);
  }

  // Issue has been created, and any missing human messages have been added to it.

  const commandUpdate: ManagerGraphUpdate = {
    messages: newMessages,
    ...(githubIssueId ? { githubIssueId } : {}),
  };

  if ((toolCallArgs.route as any) === "code") {
    // If the route was code, we don't need to do anything since the issue now contains the new messages, and the coding agent will handle pulling them in.
    return new Command({
      update: commandUpdate,
      goto: END,
    });
  }

  if (toolCallArgs.route === "plan") {
    // Always kickoff a new start planner node. This will enqueue new runs on the planner graph.
    return new Command({
      update: commandUpdate,
      goto: "start-planner",
    });
  }

  throw new Error(`Invalid route: ${toolCallArgs.route}`);
}
